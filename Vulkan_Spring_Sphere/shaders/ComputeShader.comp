#version 450

struct SphereNode {
    vec4 pos;
    vec4 color;
    vec4 prevPos;
    vec4 originPos;
    vec4 normal;
    float isFixed;
    float isSurface;
    float _padding[2];
};

// C++에서 설정한 Descriptor Sets와 매칭
layout(std430, binding = 0) readonly buffer InputNodes {
    SphereNode nodesIn[];
};

layout(std430, binding = 1) writeonly buffer OutputNodes {
    SphereNode nodesOut[];
};

// dt(타임스텝)를 받는 Push Constant
layout(push_constant) uniform PushConstants {
    float dt;
    float u_Time; // 누적된 전체 시간
};

// 워크그룹 크기 설정 (16x16 그리드이므로 16x16x1 권장)
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// 시뮬레이션 상수
const float springRestLength = 0.1;
const float springStiffness = 150.0;
const float damping = 0.95;
const vec3 gravity = vec3(0.0, -1.2, 0.0);
const int WIDTH = 16;
const int HEIGHT = 16;
const int DEPTH = 16;

float windStrength = 2.0; 
float frequency = 0.5; // 흔들리는 속도


void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    if (x >= WIDTH || y >= HEIGHT || z >= DEPTH) return;

    uint index = z * WIDTH * HEIGHT + y * WIDTH + x;
    SphereNode current = nodesIn[index];

    // 고정된 노드는 위치 변화 없음
    if (current.isFixed > 0.5) {
        nodesOut[index] = current;
        return;
    }

    vec3 pos = current.pos.xyz;
    vec3 prevPos = current.prevPos.xyz;
    vec3 originPos = current.originPos.xyz;

    //vec3 wind = vec3(0.0, 0.0, sin(u_Time * frequency) * windStrength);
    //vec3 wind = vec3(0.0, 0.0, windStrength);

    //vec3 force = gravity + wind; // 중력 적용
    vec3 force = gravity; // 중력 적용

// --- 3차원 스프링 힘 계산 (인접한 26개 노드 탐색) ---
for (int i = -1; i <= 1; i++) {
    for (int j = -1; j <= 1; j++) {
        for (int k = -1; k <= 1; k++) {
            // 자기 자신(중심 노드)은 제외
            if (i == 0 && j == 0 && k == 0) continue;

            int nx = int(x) + i;
            int ny = int(y) + j;
            int nz = int(z) + k;

            // 3차원 경계 검사 (WIDTH, HEIGHT, DEPTH 상정)
            if (nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && nz >= 0 && nz < DEPTH) {
                // 3차원 인덱싱: (z * 면적) + (y * 가로) + x
                uint neighborIndex = uint(nz * WIDTH * HEIGHT + ny * WIDTH + nx);
                vec3 neighborPos = nodesIn[neighborIndex].pos.xyz;
                vec3 neighborOriginPos = nodesIn[neighborIndex].originPos.xyz;

                vec3 diff = pos - neighborPos;
                float dist = length(diff);

                // --- restLength 보정 (3차원 대각선) ---
                // 변화된 좌표의 개수를 카운트하여 거리 계산
                // 1개: 직선(1.0), 2개: 평면 대각선(√2), 3개: 입체 대각선(√3)
                float restLen = length(originPos - neighborOriginPos);

                if (dist > 0.0001) {
                    // 훅의 법칙 (Hooke's Law)
                    force -= springStiffness * (dist - restLen) * (diff / dist);
                }
            }
        }
    }
}

    // --- 베를레 적분 (Verlet Integration) ---
    // 가속도 a = F / m (질량 m=1.0 가정)
    vec3 acceleration = force;
    
    // pos_new = pos + (pos - prevPos) * damping + a * dt^2
    vec3 newPos = pos + (pos - prevPos) * damping + acceleration * dt * dt;

    if (newPos.y < -1.5) {
        //newPos.y = -1.5;
        // 마찰력 효과: 바닥에 닿으면 x, z 이동을 줄임
        // prevPos = vec4(newPos.x, newPos.y, newPos.z, 1.0); 
    }
    // 결과 저장

    nodesOut[index] = current;
    nodesOut[index].pos = vec4(newPos, 1.0);
    nodesOut[index].prevPos = vec4(pos, 1.0); // 현재 위치가 다음 프레임의 이전 위치가 됨
}